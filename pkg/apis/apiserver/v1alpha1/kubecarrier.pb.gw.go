/*
Copyright 2020 The KubeCarrier Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: kubecarrier.proto

/*
Package v1alpha1 is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package v1alpha1

import (
	"context"
	"io"
	"net/http"

	"github.com/golang/protobuf/descriptor"
	"github.com/golang/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage

func request_KubecarrierV1Alpha1_Version_0(ctx context.Context, marshaler runtime.Marshaler, client KubecarrierV1Alpha1Client, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq VersionRequest
	var metadata runtime.ServerMetadata

	msg, err := client.Version(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_KubecarrierV1Alpha1_Version_0(ctx context.Context, marshaler runtime.Marshaler, server KubecarrierV1Alpha1Server, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq VersionRequest
	var metadata runtime.ServerMetadata

	msg, err := server.Version(ctx, &protoReq)
	return msg, metadata, err

}

// RegisterKubecarrierV1Alpha1HandlerServer registers the http handlers for service KubecarrierV1Alpha1 to "mux".
// UnaryRPC     :call KubecarrierV1Alpha1Server directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
func RegisterKubecarrierV1Alpha1HandlerServer(ctx context.Context, mux *runtime.ServeMux, server KubecarrierV1Alpha1Server) error {

	mux.Handle("GET", pattern_KubecarrierV1Alpha1_Version_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_KubecarrierV1Alpha1_Version_0(rctx, inboundMarshaler, server, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_KubecarrierV1Alpha1_Version_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterKubecarrierV1Alpha1HandlerFromEndpoint is same as RegisterKubecarrierV1Alpha1Handler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterKubecarrierV1Alpha1HandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterKubecarrierV1Alpha1Handler(ctx, mux, conn)
}

// RegisterKubecarrierV1Alpha1Handler registers the http handlers for service KubecarrierV1Alpha1 to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterKubecarrierV1Alpha1Handler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterKubecarrierV1Alpha1HandlerClient(ctx, mux, NewKubecarrierV1Alpha1Client(conn))
}

// RegisterKubecarrierV1Alpha1HandlerClient registers the http handlers for service KubecarrierV1Alpha1
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "KubecarrierV1Alpha1Client".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "KubecarrierV1Alpha1Client"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "KubecarrierV1Alpha1Client" to call the correct interceptors.
func RegisterKubecarrierV1Alpha1HandlerClient(ctx context.Context, mux *runtime.ServeMux, client KubecarrierV1Alpha1Client) error {

	mux.Handle("GET", pattern_KubecarrierV1Alpha1_Version_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_KubecarrierV1Alpha1_Version_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_KubecarrierV1Alpha1_Version_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_KubecarrierV1Alpha1_Version_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"v1alpha1", "version"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
	forward_KubecarrierV1Alpha1_Version_0 = runtime.ForwardResponseMessage
)
